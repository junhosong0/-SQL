# 인덱스의 실제 사용
단순 보조 인덱스 및 고유 보조 인덱스를 생성하고 제거하는 방법을 익히고 MySQL의 실행 계획에서 인덱스를 효율적으로 사용하는 방법을 알아보자.


## 인덱스 생성과 제거 문법

### 인덱스 생성 문법
테이블 생성 시 PK와 UNIQUE를 지정하면 인덱스가 자동으로 생성됨. 그 외에 직접 인덱스를 추가 생성하려면 **CREATE INDEX** 문을 사용해야 함.


**인덱스 생성**
```sql
CREATE [UNIQUE] INDEX 인덱스_이름
  ON 테이블_이름 (열_이름) [ASC | DESC]
```
**UNIQUE**는 중복이 안되는 고유 인덱스를 만드는 것. 생략하면 중복이 허용됨. CREATE UNIQUE로 인덱스 생성하기 위해서는 기존에 입력된 값들에 중복이 있으면 안됨. 그리고 인덱스 생성 후에 입력되는 데이터와도 중복될 수 없으니 신중해야함. 예를들어 이름을 UNIQUE로 지정하면 동명이인 회원 입력 못하게 됨.

인덱스 생성시 기본이 오름차순인 ASC임. 내림차순을 원하면 DESC를 따로 지정해줘야 함.


### 인덱스 제거 문법
주의할 점은 PK와 UNIQUE키로 자동생성된 인덱스는 DROP INDEX로 제거하지 못함. ALTER TABLE 문으로 기본 키나 고유 키를 제거하면 자동으로 생성된 인덱스도 제거할 수 있음.

**인덱스 제거**
```sql
DROP INDEX 인덱스_이름 ON 테이블_이름
```



## 인덱스 생성과 제거 실습
실제 문법 자체는 어렵지 않음. 내부적인 변화를 이해하는 것이 더욱 중요함.

### 인덱스 생성 실습


```sql
USE market_db;
SELECT * FROM member;

SHOW INDEX FROM member; -- member 테이블의 인덱스 요약 확인, mem_id에 PK지정되어 있는 것 확인

SHOW TABLE STATUS LIKE 'member'; 
```

![20240304_103440](https://github.com/junhosong0/MySQL/assets/117610783/51c435b8-1d68-4d00-a5e1-240916ec28d1)

**SHOW TABLE STATUS LIKE 'member':** 테이블의 인덱스 정보 상세 보기, 인덱스의 다른 정보도 나옴. Data_length 16384(16kb))가 나오는데 한 페이지의 크기가 16kb임. 요약하자면 해당 인덱스는 한페이지의 책이라고 보면 됨. Index_length는 보조 인덱스의 크기임. 현재는 보조 인덱스가 없어 0으로 표기 됨.



**보조인덱스 생성**

```sql
CREATE INDEX idx_member_addr 
   ON member (addr); -- member테이블의 addr열에 인덱스를 만듬.

SHOW INDEX FROM member;

ANALYZE TABLE member; -- 인덱스를 만들고 나서는 ANALYZE TABLE문으로 실제 적용을 시켜줘야 함. 그렇지 않으면 적용 안됨.
SHOW TABLE STATUS LIKE 'member';
```
![20240304_103747](https://github.com/junhosong0/MySQL/assets/117610783/69fe4085-e627-4902-b4db-26ab4be91c95)

이전과 다르게 보조 인덱스가 1개 추가되었음. 신규 인덱스는 Non_unique가 1로 되어있음. 중복 허용한다는 얘기임.



**UNIQUE 인덱스 생성**
- UNIQUE 인덱스는 고유 인덱스이기 때문에 데이터 중복 안됨.


```sql
# 멤버 수로 생성
CREATE UNIQUE INDEX idx_member_mem_number
    ON member (mem_number); -- 오류 발생. member 테이블의 mem_number 데이터 중 중복되는 경우가 있기 때문.

# 회원 이름으로 생성
CREATE UNIQUE INDEX idx_member_mem_name
    ON member (mem_name); -- 현재 상황에서는 중복되는 회원이름이 없기 때문에 오류는 발생하지 않지만 향후 데이터 추가 시 중복되는 데이터가 있을 확률이 높때문에 상당히 위험함.


# 지금까지 만든 인덱스 모두 적용
ANALYZE

```



